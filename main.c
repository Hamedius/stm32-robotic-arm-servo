/* main.c - Robotic Arm Servo Motor Controlling
 *
 * Board:    STM32 Nucleo-G474RE (or similar STM32G4)
 *
 * Function:
 *   - Read 3 potentiometers via ADC
 *   - Map ADC readings (0–4096) to servo angles (0–180 degrees)
 *   - Convert angles to PWM duty cycles (CCR values) for 3 servo motors
 *
 * Peripherals (according to project report):
 *   - POT 1 -> PA0  -> ADC1_IN1       -> controls SERVO 1 on TIM2_CH2 (PA1)
 *   - POT 2 -> PA4  -> ADC2_IN1       -> controls SERVO 2 on TIM3_CH3 (PB0)
 *   - POT 3 -> PA9  -> ADC5_IN1       -> controls SERVO 3 on TIM1_CH1 (PC0)
 *
 * Timer configuration (for all 3 servos):
 *   - HCLK       = 45 MHz
 *   - Timer PSC  = 900 - 1
 *   - Timer ARR  = 1000 - 1
 *   -> PWM frequency = 50 Hz (period 20 ms)
 *
 * Pulse width mapping:
 *   - 0.5 ms  -> CCR = 25   -> 0 degrees
 *   - 1.5 ms  -> CCR = 75   -> 90 degrees
 *   - 2.5 ms  -> CCR = 125  -> 180 degrees
 *
 * NOTE:
 *   This file is structured like a typical STM32Cube HAL main.c.
 *   SystemClock_Config() and MX_*_Init() bodies are expected to be
 *   generated by STM32CubeMX for the specific board configuration.
 */

#include "main.h"

/* ADC handles */
ADC_HandleTypeDef hadc1;   // POT 1
ADC_HandleTypeDef hadc2;   // POT 2
ADC_HandleTypeDef hadc5;   // POT 3

/* TIM handles */
TIM_HandleTypeDef htim1;   // SERVO 3 (TIM1_CH1)
TIM_HandleTypeDef htim2;   // SERVO 1 (TIM2_CH2)
TIM_HandleTypeDef htim3;   // SERVO 2 (TIM3_CH3)

/* Application variables */
uint16_t readValue;   // Servo 1 potentiometer reading 0–4096
uint16_t Degree;      // Servo 1 angle 0–180
uint16_t Angle;       // Servo 1 CCR value

uint16_t readValue2;  // Servo 2 potentiometer reading 0–4096
uint16_t Degree2;     // Servo 2 angle 0–180
uint16_t Angle2;      // Servo 2 CCR value

uint16_t readValue3;  // Servo 3 potentiometer reading 0–4096
uint16_t Degree3;     // Servo 3 angle 0–180
uint16_t Angle3;      // Servo 3 CCR value;

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_ADC1_Init(void);
static void MX_ADC2_Init(void);
static void MX_ADC5_Init(void);
static void MX_TIM1_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM3_Init(void);

int main(void)
{
  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* Configure the system clock */
  SystemClock_Config();

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_ADC1_Init();
  MX_ADC2_Init();
  MX_ADC5_Init();
  MX_TIM1_Init();
  MX_TIM2_Init();
  MX_TIM3_Init();

  /* Start ADCs and PWM channels */
  HAL_ADC_Start(&hadc1);                          // Servo 1
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);       // Servo 1

  HAL_ADC_Start(&hadc2);                          // Servo 2
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);       // Servo 2

  HAL_ADC_Start(&hadc5);                          // Servo 3
  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);       // Servo 3

  while (1)
  {
    /* ---- Servo 1 ---- */
    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, 1000);
    readValue = HAL_ADC_GetValue(&hadc1);

    Degree = (uint16_t)((readValue * 180U) / 4096U);           // 0–180 deg
    Angle  = (uint16_t)(25U + (100U * Degree) / 180U);         // 25–125 CCR
    htim2.Instance->CCR2 = Angle;                              // TIM2 CH2

    /* ---- Servo 2 ---- */
    HAL_ADC_Start(&hadc2);
    HAL_ADC_PollForConversion(&hadc2, 1000);
    readValue2 = HAL_ADC_GetValue(&hadc2);

    Degree2 = (uint16_t)((readValue2 * 180U) / 4096U);
    Angle2  = (uint16_t)(25U + (100U * Degree2) / 180U);
    htim3.Instance->CCR3 = Angle2;                             // TIM3 CH3

    /* ---- Servo 3 ---- */
    HAL_ADC_Start(&hadc5);
    HAL_ADC_PollForConversion(&hadc5, 1000);
    readValue3 = HAL_ADC_GetValue(&hadc5);

    Degree3 = (uint16_t)((readValue3 * 180U) / 4096U);
    Angle3  = (uint16_t)(25U + (100U * Degree3) / 180U);
    htim1.Instance->CCR1 = Angle3;                             // TIM1 CH1
  }
}

/* The following initialization functions are placeholders.
 * Generate their content with STM32CubeMX for your exact hardware.
 */

void SystemClock_Config(void)
{
  /* Configure system clock for HCLK = 45 MHz as required.
   * Use STM32CubeMX to generate this function.
   */
}

static void MX_GPIO_Init(void)
{
  /* Configure GPIO pins for ADC, PWM and any status LEDs.
   * Use STM32CubeMX to generate this function.
   */
}

static void MX_ADC1_Init(void)
{
  /* Configure ADC1 for POT 1 (PA0, ADC1_IN1). */
}

static void MX_ADC2_Init(void)
{
  /* Configure ADC2 for POT 2 (PA4, ADC2_IN1). */
}

static void MX_ADC5_Init(void)
{
  /* Configure ADC5 for POT 3 (PA9, ADC5_IN1). */
}

static void MX_TIM1_Init(void)
{
  /* Configure TIM1_CH1 on PC0 for Servo 3.
   * Set PSC = 900 - 1, ARR = 1000 - 1 for 50 Hz PWM.
   */
}

static void MX_TIM2_Init(void)
{
  /* Configure TIM2_CH2 on PA1 for Servo 1.
   * Set PSC = 900 - 1, ARR = 1000 - 1 for 50 Hz PWM.
   */
}

static void MX_TIM3_Init(void)
{
  /* Configure TIM3_CH3 on PB0 for Servo 2.
   * Set PSC = 900 - 1, ARR = 1000 - 1 for 50 Hz PWM.
   */
}

void Error_Handler(void)
{
  __disable_irq();
  while (1)
  {
  }
}
